package main

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, file := range gen.Files {
			if file.Generate {
				err := generateFile(gen, file)
				if err != nil {
					gen.Error(err)
				}
			}
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	oneofs := findOneofs(file)

	for _, oneof := range oneofs {
		for _, field := range oneof.Fields {
			if field.Desc.Kind() != protoreflect.MessageKind {
				return fmt.Errorf(
					"%s: dispatcher doesn't support %q type in oneof",
					field.Location.SourceFile,
					field.Desc.Kind().String(),
				)
			}
		}
	}

	g := gen.NewGeneratedFile(file.GeneratedFilenamePrefix+".dispatcher.go", file.GoImportPath)
	g.P("// Code generated by protoc-gen-dispatcher. DO NOT EDIT.")
	protocVersion := "(unknown)"
	if v := gen.Request.GetCompilerVersion(); v != nil {
		protocVersion = fmt.Sprintf("v%v.%v.%v", v.GetMajor(), v.GetMinor(), v.GetPatch())
		if s := v.GetSuffix(); s != "" {
			protocVersion += "-" + s
		}
	}
	g.P("// protoc version: ", protocVersion)
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	if len(oneofs) == 0 {
		return nil
	}

	g.P(`import "studentgit.kata.academy/quant/torque/pkg/logster"`)
	g.P()

	for _, oneof := range oneofs {
		generateDispatcher(g, oneof)
	}

	return nil
}

func findOneofs(file *protogen.File) []*protogen.Oneof {
	var walkMessages func([]*protogen.Message, func(*protogen.Message))
	walkMessages = func(messages []*protogen.Message, f func(*protogen.Message)) {
		for _, m := range messages {
			f(m)
			walkMessages(m.Messages, f)
		}
	}

	var oneofs []*protogen.Oneof

	walkMessages(file.Messages, func(m *protogen.Message) {
		for _, oneof := range m.Oneofs {
			if strings.Contains(oneof.Comments.Leading.String(), "//dispatcher:generate") {
				oneofs = append(oneofs, oneof)
			}
		}
	})
	return oneofs
}

func generateDispatcher(g *protogen.GeneratedFile, oneof *protogen.Oneof) {
	msgGoTypeName := oneof.Parent.GoIdent.GoName
	ackableMsgGoTypeName := "Ackable" + msgGoTypeName
	d := msgGoTypeName + "Dispatcher"
	loopVar := private(msgGoTypeName)
	switchVar := private(oneof.GoName)
	dFieldName := func(field *protogen.Field) string {
		return private(field.GoName)
	}
	dFieldMsgGoTypeName := func(field *protogen.Field) string {
		return field.Message.GoIdent.GoName
	}
	dFieldAckableMsgGoTypeName := func(field *protogen.Field) string {
		return "Ackable" + field.Message.GoIdent.GoName
	}
	dFieldWrapperGoTypeName := func(field *protogen.Field) string {
		return field.GoIdent.GoName
	}

	g.P("type ", ackableMsgGoTypeName, " struct {")
	g.P("  ", msgGoTypeName, " *", msgGoTypeName)
	g.P("  Ack func()")
	g.P("}")
	g.P()
	for _, field := range oneof.Fields {
		g.P("type ", dFieldAckableMsgGoTypeName(field), " struct {")
		g.P("  ", dFieldMsgGoTypeName(field), " *", dFieldMsgGoTypeName(field))
		g.P("  Ack func()")
		g.P("}")
		g.P()
	}
	g.P("type ", d, " struct {")
	g.P("  logger logster.Logger")
	g.P("  started bool")
	for _, field := range oneof.Fields {
		g.P(dFieldName(field), " chan ", dFieldAckableMsgGoTypeName(field))
	}
	g.P("}")
	g.P()
	g.P("func New", d, "(logger logster.Logger) *", d, " {")
	g.P("  return &", d, "{")
	g.P("    logger: logger,")
	g.P("  }")
	g.P("}")
	g.P()
	g.P("func (d *", d, ") Run(ch <-chan ", ackableMsgGoTypeName, ") {")
	g.P("  d.started = true")
	g.P("  for ", loopVar, " := range ch {")
	g.P("    switch ", switchVar, " := ", loopVar, ".", msgGoTypeName, ".", oneof.GoName, ".(type) {")
	for _, field := range oneof.Fields {
		g.P("  case *", dFieldWrapperGoTypeName(field), ":")
		g.P("    if d.", dFieldName(field), " != nil {")
		g.P("      d.", dFieldName(field), " <- ", dFieldAckableMsgGoTypeName(field), "{")
		g.P("        ", dFieldMsgGoTypeName(field), ": ", switchVar, ".", field.GoName, ",")
		g.P("        Ack: ", loopVar, ".Ack,")
		g.P("      }")
		g.P("    } else {")
		g.P("        ", loopVar, ".Ack()")
		g.P("    }")
	}
	g.P("    default:")
	g.P(`      d.logger.Errorf("unknown type %T", `, switchVar, ")")
	g.P("    }")
	g.P("  }")
	for _, field := range oneof.Fields {
		g.P()
		g.P("if d.", dFieldName(field), " != nil {")
		g.P("  close(d.", dFieldName(field), ")")
		g.P("}")
	}
	g.P("}")
	g.P()
	for _, field := range oneof.Fields {
		g.P("func (d *", d, ") ", dFieldMsgGoTypeName(field), "() <-chan ", dFieldAckableMsgGoTypeName(field), " {")
		g.P("  if d.", dFieldName(field), " != nil {")
		g.P(`    panic("`, dFieldMsgGoTypeName(field), ` already called")`)
		g.P("  }")
		g.P("  if d.started {")
		g.P(`    panic("`, dFieldMsgGoTypeName(field), ` called after Run")`)
		g.P("  }")
		g.P("  d.", dFieldName(field), " = make(chan ", dFieldAckableMsgGoTypeName(field), ")")
		g.P("  return d.", dFieldName(field))
		g.P("}")
		g.P()
	}
}

func private(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}
